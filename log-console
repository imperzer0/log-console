#include <utility>
#include <iostream>
#include <termios.h>
//
// Created by imper on 6/12/21.
//
#ifndef KAZKUEME_LOG_CONSOLE_HPP
#define KAZKUEME_LOG_CONSOLE_HPP

template <typename T, T val>
struct val_is
{
	static constexpr T value = val;
};

template <typename T>
struct type_is
{
	using type = T;
};

template <bool, auto T_val, auto>
struct choose_val : val_is<decltype(T_val), T_val>
{
};

template <auto T_val, auto F_val>
struct choose_val<false, T_val, F_val> : val_is<decltype(F_val), F_val>
{
};

template <bool, typename T>
struct enable_if : type_is<T>
{
};

template <typename T>
struct enable_if<false, T>
{
};

struct check_for_unary_minus
{
	template <typename U, typename = decltype(-std::declval<U>())>
	static constexpr std::true_type perform(U&& u)
	{
		return std::true_type();
	}
	
	static constexpr std::false_type perform(...)
	{
		return std::false_type();
	}
};

struct check_for_less
{
	template <typename U, typename = decltype(std::declval<const U&>() < std::declval<const U&>())>
	static constexpr std::true_type perform(U&& u)
	{
		return std::true_type();
	}
	
	static constexpr std::false_type perform(...)
	{
		return std::false_type();
	}
};

template <typename char_t>
static constexpr size_t static_strlen(const char_t* str)
{
	size_t size(0);
	for (; *str; ++str)
	{
		++size;
	}
	return size;
}

template <bool expr, typename T> using enable_if_t = typename enable_if<expr, T>::type;

#define l_location std::pair<const char*, std::pair<const char*, int>>(__FILE__, {__func__, __LINE__})
#define l_time std::pair<const char*, const char*>(__DATE__, __TIME__)

namespace color
{
	static constexpr const char* reset      = "\033[0m";
	static constexpr const char* bold       = "\033[1m";
	static constexpr const char* light      = "\033[2m";
	static constexpr const char* italic     = "\033[3m";
	static constexpr const char* underlined = "\033[4m";
	static constexpr const char* blinking   = "\033[5m";
	static constexpr const char* default_bg = "\033[7m";
	static constexpr const char* strikeout  = "\033[9m";
	static constexpr const char* red        = "\033[31m";
	static constexpr const char* green      = "\033[32m";
	static constexpr const char* yellow     = "\033[33m";
	static constexpr const char* blue       = "\033[34m";
	static constexpr const char* purple     = "\033[35m";
	static constexpr const char* aqua       = "\033[36m";
	static constexpr const char* white      = "\033[37m";
	static constexpr const char* black_bg   = "\033[40m";
	static constexpr const char* red_bg     = "\033[41m";
	static constexpr const char* green_bg   = "\033[42m";
	static constexpr const char* yellow_bg  = "\033[43m";
	static constexpr const char* blue_bg    = "\033[44m";
	static constexpr const char* purple_bg  = "\033[45m";
	static constexpr const char* aqua_bg    = "\033[46m";
	static constexpr const char* white_bg   = "\033[47m";
}

class log_console
{
public:
	typedef void               (* state_change_function)(log_console& logger);
	
	template <typename T>
	using val_set_function = void (*)(log_console& logger, T val);
	
	enum l_flags : unsigned long
	{
		l_lock, l_unlock, l_flush, l_endl, l_locendl, l_endent
	};
	
	explicit log_console(int output_stream_socket);
	
	explicit log_console(FILE* output_stream);
	
	~log_console();
	
	inline void print(const std::string& str) const;
	
	inline void print(const char& char_) const;
	
	inline void flush();
	
	template <typename num_t>
	static inline constexpr num_t abs(num_t num);
	
	template <typename int_t>
	[[nodiscard]] static enable_if_t<std::is_integral_v<int_t>, std::string&> integral_to_string(int_t value, int radix);
	
	static inline void set_base(log_console& logger, int base)
	{
		logger.base = base;
	}
	
	static inline void hex(log_console& logger)
	{
		logger.base = 16;
	}
	
	static inline void dec(log_console& logger)
	{
		logger.base = 10;
	}
	
	static inline void oct(log_console& logger)
	{
		logger.base = 8;
	}
	
	static inline void tetra(log_console& logger)
	{
		logger.base = 4;
	}
	
	static inline void bin(log_console& logger)
	{
		logger.base = 2;
	}
	
	static inline void flush(log_console& logger)
	{
		logger.flush();
	}
	
	static inline void lock();
	
	static inline void unlock();
	
	static inline void setting_stdin();
	
	static inline void setting_stdout();
	
	static inline void setting_stderr();
	
	static inline void reset_all();
	
	static constexpr const char* color_int_t                = color::purple;
	static constexpr const char* color_float_t              = color::blue;
	static constexpr const char* color_l_location           = "\033[35m\033[2m";
	static constexpr const char* color_l_location_separator = "\033[33m\033[2m";
	static constexpr const char* color_l_time               = "\033[35m\033[2m";
	static constexpr const char* color_l_time_separator     = "\033[33m\033[2m";
	static constexpr const char* color_bool_true            = color::green;
	static constexpr const char* color_bool_false           = color::red;
	static constexpr const char* log_arrow                  = "+--> ";
	
	inline static void on(log_console& logger)
	{ logger.is_logging_on = true; }
	
	inline static void off(log_console& logger)
	{ logger.is_logging_on = false; }

private:
	friend inline log_console& operator<<(log_console& logger, log_console::state_change_function state_change_function);
	
	friend inline const std::pair<log_console&, std::true_type>&
	operator<<(const std::pair<log_console&, std::true_type>& logger, log_console::state_change_function state_change_function);
	
	template <typename T>
	friend inline const std::pair<log_console&, log_console::val_set_function<T>>&
	operator<<(log_console& logger, log_console::val_set_function<T> val_set_function);
	
	template <typename T>
	friend inline const std::pair<log_console&, log_console::val_set_function<T>>&
	operator<<(const std::pair<log_console&, std::true_type>& logger, log_console::val_set_function<T> val_set_function);
	
	template <typename T>
	friend inline const std::pair<log_console&, std::true_type>&
	operator<<(const std::pair<log_console&, log_console::val_set_function<T>>& logger, T val);
	
	friend inline const std::pair<log_console&, std::true_type>&
	operator<<(log_console& logger, const std::remove_cvref_t<decltype(l_location)>& location);
	
	friend inline const std::pair<log_console&, std::true_type>&
	operator<<(const std::pair<log_console&, std::true_type>& logger, const decltype(l_location)& location);
	
	friend inline const std::pair<log_console&, std::true_type>& operator<<(log_console& logger, const std::remove_cvref_t<decltype(l_time)>& time);
	
	friend inline log_console& operator<<(const std::pair<log_console&, std::true_type>& logger, const decltype(l_time)& time);
	
	friend inline log_console& operator<<(log_console& logger, const std::string& str);
	
	friend inline const std::pair<log_console&, std::true_type>&
	operator<<(const std::pair<log_console&, std::true_type>& logger, const std::string& str);
	
	friend inline log_console& operator<<(log_console& logger, const char* str);
	
	friend inline const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, const char* str);
	
	friend inline log_console& operator<<(log_console& logger, bool boolean);
	
	friend inline const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, bool boolean);
	
	friend inline log_console& operator<<(log_console& logger, log_console::l_flags flag);
	
	friend inline const std::pair<log_console&, std::true_type>&
	operator<<(const std::pair<log_console&, std::true_type>& logger, log_console::l_flags flag);
	
	template <typename type>
	friend log_console& operator<<(log_console& logger, type num);
	
	template <typename type>
	friend const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, type num);
	
	static constexpr const char* base36 = "0123456789abcdefghijklmnopqrstuvwxyz";
	static constexpr size_t BASE = static_strlen(base36);
	static struct termios* stdin_defaults;
	static struct termios* stdout_defaults;
	static struct termios* stderr_defaults;
	static pthread_mutex_t mutex;
	FILE* output_stream;
	bool     is_logging_on = true;
	bool     time          = false;
	bool     location      = false;
	unsigned base          = 10;
};

pthread_mutex_t log_console::mutex = PTHREAD_MUTEX_INITIALIZER;

log_console::log_console(int output_stream_socket) : output_stream(::fdopen(output_stream_socket, "wb"))
{ }

log_console::log_console(FILE* output_stream) : output_stream(output_stream)
{ }

log_console::~log_console()
{ ::fclose(output_stream); }

void log_console::print(const std::string& str) const
{ ::fwrite(str.c_str(), sizeof(char), str.size(), output_stream); }

void log_console::print(const char& char_) const
{ ::fwrite(&char_, sizeof(char_), 1, output_stream); }

void log_console::flush()
{ ::fflush(this->output_stream); }

template <typename num_t>
constexpr num_t log_console::abs(num_t num)
{
	static_assert(check_for_less::perform(num), "can't find less operator for passed object type");
	static_assert(check_for_unary_minus::perform(num), "can't find unary minus operator for passed object type");
	if (num < 0)
	{
		return -num;
	}
	else
	{
		return num;
	}
}

template <typename int_t>
enable_if_t<std::is_integral_v<int_t>, std::string&> log_console::integral_to_string(int_t value, int radix)
{
	auto* result = new std::string;
	if (radix > 0 && radix <= BASE)
	{
		bool negative = value < 0;
		while (value != 0)
		{
			int remainder = log_console::abs(value % radix);
			value /= radix;
			result->insert(result->begin(), log_console::base36[remainder]);
		}
		
		
		if (negative)
		{
			result->insert(result->begin(), '-');
		}
		
	}
	else
	{
		*result = "<invalid_base>";
	}
	return *result;
}

void log_console::lock()
{ pthread_mutex_lock(&log_console::mutex); }

void log_console::unlock()
{ pthread_mutex_unlock(&log_console::mutex); }

struct termios* log_console::stdin_defaults  = nullptr;
struct termios* log_console::stdout_defaults = nullptr;
struct termios* log_console::stderr_defaults = nullptr;

void log_console::setting_stdin()
{
	if (log_console::stdin_defaults == nullptr)
	{ log_console::stdin_defaults = new termios; }
	::tcgetattr(0, log_console::stdin_defaults);
	struct termios settings = *log_console::stdin_defaults;
	settings.c_lflag &= (~ICANON);
	settings.c_lflag &= (~ECHO);
	settings.c_cc[VTIME] = 0;
	settings.c_cc[VMIN]  = 1;
	::tcsetattr(0, TCSANOW, &settings);
}

void log_console::setting_stdout()
{
	if (log_console::stdout_defaults == nullptr)
	{ log_console::stdout_defaults = new termios; }
	::tcgetattr(1, log_console::stdout_defaults);
	struct termios settings = *log_console::stdout_defaults;
	settings.c_lflag &= (~ICANON);
	settings.c_lflag &= (~ECHO);
	settings.c_cc[VTIME] = 0;
	settings.c_cc[VMIN]  = 1;
	::tcsetattr(1, TCSANOW, &settings);
}

void log_console::setting_stderr()
{
	if (log_console::stderr_defaults == nullptr)
	{ log_console::stderr_defaults = new termios; }
	::tcgetattr(2, log_console::stderr_defaults);
	struct termios settings = *log_console::stderr_defaults;
	settings.c_lflag &= (~ICANON);
	settings.c_lflag &= (~ECHO);
	settings.c_cc[VTIME] = 0;
	settings.c_cc[VMIN]  = 1;
	::tcsetattr(2, TCSANOW, &settings);
}

void log_console::reset_all()
{
	if (log_console::stdin_defaults != nullptr)
	{
		::tcsetattr(0, TCSANOW, log_console::stdin_defaults);
		log_console::stdin_defaults = nullptr;
	}
	if (log_console::stdout_defaults != nullptr)
	{
		::tcsetattr(1, TCSANOW, log_console::stdout_defaults);
		log_console::stdout_defaults = nullptr;
	}
	if (log_console::stderr_defaults != nullptr)
	{
		::tcsetattr(1, TCSANOW, log_console::stderr_defaults);
		log_console::stderr_defaults = nullptr;
	}
}

// static operators

inline log_console& operator<<(log_console& logger, log_console::state_change_function state_change_function)
{
	logger.time     = false;
	logger.location = false;
	state_change_function(logger);
	return logger;
}

inline const std::pair<log_console&, std::true_type>&
operator<<(const std::pair<log_console&, std::true_type>& logger, log_console::state_change_function state_change_function)
{
	logger.first.time     = false;
	logger.first.location = false;
	state_change_function(logger.first);
	return logger;
}

template <typename T>
inline const std::pair<log_console&, log_console::val_set_function<T>>&
operator<<(log_console& logger, log_console::val_set_function<T> val_set_function)
{
	logger.time     = false;
	logger.location = false;
	return *new std::remove_cvref_t<decltype(operator<<(logger, val_set_function))>(logger, val_set_function);
}

template <typename T>
inline const std::pair<log_console&, log_console::val_set_function<T>>&
operator<<(const std::pair<log_console&, std::true_type>& logger, log_console::val_set_function<T> val_set_function)
{
	logger.first.time     = false;
	logger.first.location = false;
	return *new std::remove_cvref_t<decltype(operator<<(logger, val_set_function))>{logger.first, val_set_function};
}

template <typename T>
inline const std::pair<log_console&, std::true_type>&
operator<<(const std::pair<log_console&, log_console::val_set_function<T>>& logger, T val)
{
	logger.first.time     = false;
	logger.first.location = false;
	logger.second(logger.first, val);
	return *new std::remove_cvref_t<decltype(operator<<(logger, val))>{logger.first, std::true_type()};
}

inline const std::pair<log_console&, std::true_type>& operator<<(log_console& logger, const std::remove_cvref_t<decltype(l_location)>& location)
{
	if (logger.is_logging_on)
	{
		logger.print((logger.location ? std::string() : std::string("\n")) + log_console::color_l_location + location.first +
					 log_console::color_l_location_separator + "::" + log_console::color_l_location + location.second.first +
					 log_console::color_l_location_separator + "::" + log_console::color_l_location + std::to_string(location.second.second) +
					 color::reset + "\n+--> "
		);
		logger.time     = false;
		logger.location = true;
	}
	return *new std::remove_cvref_t<decltype(operator<<(logger, l_location))>{logger, std::true_type()};
}

inline const std::pair<log_console&, std::true_type>&
operator<<(const std::pair<log_console&, std::true_type>& logger, const decltype(l_location)& location)
{
	if (logger.first.is_logging_on)
	{
		logger.first.print((logger.first.time ? std::string() : std::string("\n")) + log_console::color_l_location + location.first +
						   log_console::color_l_location_separator + "::" + log_console::color_l_location + location.second.first + "()" +
						   log_console::color_l_location_separator + "::" + log_console::color_l_location + std::to_string(location.second.second) +
						   color::reset + "\n+-->  "
		);
		logger.first.time     = false;
		logger.first.location = true;
	}
	return logger;
}

inline const std::pair<log_console&, std::true_type>& operator<<(log_console& logger, const std::remove_cvref_t<decltype(l_time)>& time)
{
	if (logger.is_logging_on)
	{
		logger.print(
				(logger.time ? std::string() : std::string("\n")) + log_console::color_l_time + time.first + log_console::color_l_time_separator +
				"::" + log_console::color_l_time + time.second + color::reset + "\t"
		);
		logger.time     = true;
		logger.location = false;
	}
	return *new std::remove_cvref_t<decltype(operator<<(logger, l_time))>{logger, std::true_type()};
}

inline log_console& operator<<(const std::pair<log_console&, std::true_type>& logger, const decltype(l_time)& time)
{
	if (logger.first.is_logging_on)
	{
		logger.first.print((logger.first.location ? std::string() : std::string("\n")) + log_console::color_l_time + time.first +
						   log_console::color_l_time_separator + "  " + log_console::color_l_time + time.second + color::reset + "\t"
		);
		logger.first.time     = true;
		logger.first.location = false;
	}
	return logger.first;
}

inline log_console& operator<<(log_console& logger, const std::string& str)
{
	if (logger.is_logging_on)
	{
		logger.print(str);
		logger.time     = false;
		logger.location = false;
	}
	return logger;
}

inline const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, const std::string& str)
{
	if (logger.first.is_logging_on)
	{
		std::string copy;
		for (char   i : str)
		{
			copy += i;
			if (i == '\n')
			{ copy += log_console::log_arrow; }
		}
		logger.first.print(copy);
		logger.first.time     = false;
		logger.first.location = false;
	}
	return logger;
}

inline log_console& operator<<(log_console& logger, const char* str)
{
	if (logger.is_logging_on)
	{
		logger.print(str);
		logger.time     = false;
		logger.location = false;
	}
	return logger;
}

const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, const char* str)
{
	if (logger.first.is_logging_on)
	{
		std::string copy;
		for (; *str; ++str)
		{
			copy += *str;
			if (*str == '\n')
			{ copy += log_console::log_arrow; }
		}
		logger.first.print(copy);
		logger.first.time     = false;
		logger.first.location = false;
	}
	return logger;
}

inline log_console& operator<<(log_console& logger, bool boolean)
{
	if (logger.is_logging_on)
	{
		logger.print(
				(boolean ? std::string(log_console::color_bool_true) + " true" : std::string(log_console::color_bool_false) + " false")
				+ color::reset
		);
		logger.time     = false;
		logger.location = false;
	}
	return logger;
}

inline const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, bool boolean)
{
	if (logger.first.is_logging_on)
	{
		logger.first.print((boolean ? std::string(log_console::color_bool_true) + " true" : std::string(log_console::color_bool_false) + " false")
						   + color::reset
		);
		logger.first.time     = false;
		logger.first.location = false;
	}
	return logger;
}

inline log_console& operator<<(log_console& logger, log_console::l_flags flag)
{
	if (logger.is_logging_on)
	{
		switch (flag)
		{
			case log_console::l_flags::l_lock:
				log_console::lock();
				break;
			case log_console::l_flags::l_unlock:
				log_console::unlock();
				break;
			case log_console::l_flags::l_flush:
				logger.flush();
				break;
			case log_console::l_flags::l_endl:
				logger.print("\n");
				logger.flush();
				break;
			case log_console::l_flags::l_locendl:
				logger.print("\n");
				logger.print(log_console::log_arrow);
				logger.flush();
				break;
			case log_console::l_flags::l_endent:
				logger.print("\n");
				logger.flush();
				log_console::unlock();
				break;
		}
	}
	return logger;
}

inline const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, log_console::l_flags flag)
{
	if (logger.first.is_logging_on)
	{
		switch (flag)
		{
			case log_console::l_flags::l_lock:
				log_console::lock();
				break;
			case log_console::l_flags::l_unlock:
				log_console::unlock();
				break;
			case log_console::l_flags::l_flush:
				logger.first.flush();
				break;
			case log_console::l_flags::l_endl:
				logger.first.print("\n");
				logger.first.flush();
				break;
			case log_console::l_flags::l_locendl:
				logger.first.print("\n");
				logger.first.print(log_console::log_arrow);
				logger.first.flush();
				break;
			case log_console::l_flags::l_endent:
				logger.first.print("\n");
				logger.first.flush();
				log_console::unlock();
				break;
		}
	}
	return logger;
}

template <typename type>
log_console& operator<<(log_console& logger, type num)
{
	if (logger.is_logging_on)
	{
		logger.time     = false;
		logger.location = false;
		
		if constexpr(std::is_same_v<type, char>)
		{
			logger.print(num);
		}
		else if constexpr(std::is_integral_v<type>)
		{
			logger.print(log_console::color_int_t + log_console::integral_to_string(num, logger.base) + color::reset);
		}
		else if constexpr(std::is_floating_point_v<type>)
		{
			logger.print(log_console::color_float_t + log_console::integral_to_string(num, logger.base) + color::reset);
		}
		else
		{
			logger.print(num);
		}
	}
	return logger;
}

template <typename type>
const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, type num)
{
	if (logger.first.is_logging_on)
	{
		logger.first.time     = false;
		logger.first.location = false;
		
		if constexpr(std::is_same_v<type, char>)
		{
			logger.first.print(num);
		}
		else if constexpr(std::is_integral_v<type>)
		{
			logger.first.print(log_console::color_int_t + log_console::integral_to_string(num, logger.first.base) + color::reset);
		}
		else if constexpr(std::is_floating_point_v<type>)
		{
			logger.first.print(log_console::color_float_t + log_console::integral_to_string(num, logger.first.base) + color::reset);
		}
	}
	return logger;
}

#endif //KAZKUEME_LOG_CONSOLE_HPP