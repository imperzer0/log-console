#include <utility>
#include <iostream>
#include <termios.h>

//
// Created by imper on 6/12/21.
//

#ifndef KAZKUEME_LOG_CONSOLE_HPP
#define KAZKUEME_LOG_CONSOLE_HPP

template <typename T, T val>
struct val_is
{
	static constexpr T value = val;
};

template <typename T>
struct type_is
{
	using type = T;
};

template <bool, auto T_val, auto>
struct choose_val : val_is<decltype(T_val), T_val>
{
};

template <auto T_val, auto F_val>
struct choose_val<false, T_val, F_val> : val_is<decltype(F_val), F_val>
{
};

template <bool, typename T>
struct enable_if : type_is<T>
{
};

template <typename T>
struct enable_if<false, T>
{
};

template <bool expr, typename T>
using enable_if_t = typename enable_if<expr, T>::type;

#define l_location std::pair<const char*, std::pair<const char*, int>>(__FILE__, {__func__, __LINE__})
#define l_time std::pair<const char*, const char*>(__DATE__, __TIME__)

namespace color
{
	static constexpr const char* reset = "\033[0m";
	static constexpr const char* bold = "\033[1m";
	static constexpr const char* light = "\033[2m";
	static constexpr const char* italic = "\033[3m";
	static constexpr const char* underlined = "\033[4m";
	static constexpr const char* blinking = "\033[5m";
	static constexpr const char* default_bg = "\033[7m";
	static constexpr const char* strikeout = "\033[9m";
	static constexpr const char* red = "\033[31m";
	static constexpr const char* green = "\033[32m";
	static constexpr const char* yellow = "\033[33m";
	static constexpr const char* blue = "\033[34m";
	static constexpr const char* purple = "\033[35m";
	static constexpr const char* aqua = "\033[36m";
	static constexpr const char* white = "\033[37m";
	static constexpr const char* black_bg = "\033[40m";
	static constexpr const char* red_bg = "\033[41m";
	static constexpr const char* green_bg = "\033[42m";
	static constexpr const char* yellow_bg = "\033[43m";
	static constexpr const char* blue_bg = "\033[44m";
	static constexpr const char* purple_bg = "\033[45m";
	static constexpr const char* aqua_bg = "\033[46m";
	static constexpr const char* white_bg = "\033[47m";
}

class log_console
{
public:
	bool time = false;
	bool location = false;
	
	explicit log_console(int output_stream_socket);
	
	explicit log_console(FILE* output_stream);
	
	inline const std::pair<log_console&, std::true_type>& operator<<(const std::remove_cvref_t<decltype(l_location)>& location);
	
	inline const std::pair<log_console&, std::true_type>& operator<<(const std::remove_cvref_t<decltype(l_time)>& time);
	
	inline log_console& operator<<(const std::string& str);
	
	inline log_console& operator<<(const char* str);
	
	inline log_console& operator<<(bool boolean);
	
	template <typename type>
	inline enable_if_t<std::is_integral_v<type>, log_console&> operator<<(type num);
	
	template <typename type>
	inline enable_if_t<std::is_floating_point_v<type>, log_console&> operator<<(type num);
	
	~log_console();
	
	void print(const std::string& str) const;
	
	
	static inline void setting_stdin();
	
	static inline void setting_stdout();
	
	static inline void setting_stderr();
	
	static inline void reset_all();
	
	
	static constexpr char color_int_t[]{"\033[35m"};
	static constexpr char color_float_t[]{"\033[34m"};
	static constexpr char color_l_location[]{"\033[35m\033[2m"};
	static constexpr char color_l_location_separator[]{"\033[33m\033[2m"};
	static constexpr char color_l_time[]{"\033[35m\033[2m"};
	static constexpr char color_l_time_separator[]{"\033[33m\033[2m"};
	static constexpr char color_bool_true[]{"\033[32m"};
	static constexpr char color_bool_false[]{"\033[31m"};

private:
	static struct termios* stdin_defaults;
	static struct termios* stdout_defaults;
	static struct termios* stderr_defaults;
	
	FILE* output_stream;
};

log_console::log_console(int output_stream_socket) : output_stream(::fdopen(output_stream_socket, "wb"))
{ }

log_console::log_console(FILE* output_stream) : output_stream(output_stream)
{ }

const std::pair<log_console&, std::true_type>& log_console::operator<<(const std::remove_cvref_t<decltype(l_location)>& location)
{
	print(
			(this->location ? std::string() : std::string("\n")) + color_l_location + location.first
			+ color_l_location_separator + "::" + color_l_location + location.second.first
			+ color_l_location_separator + "::" + color_l_location + std::to_string(location.second.second)
			+ color::reset + "\n+-->"
	);
	this->time = false;
	this->location = true;
	return *new std::remove_cvref_t<decltype(operator<<(l_location))>{*this, std::true_type()};
}

const std::pair<log_console&, std::true_type>& log_console::operator<<(const std::remove_cvref_t<decltype(l_time)>& time)
{
	print(
			(this->time ? std::string() : std::string("\n")) + color_l_time + time.first
			+ color_l_time_separator + "::" + color_l_time + time.second
			+ color::reset + "\t"
	);
	this->time = true;
	this->location = false;
	return *new std::remove_cvref_t<decltype(operator<<(l_time))>{*this, std::true_type()};
}

log_console& log_console::operator<<(const std::string& str)
{
	print(str);
	this->time = false;
	this->location = false;
	return *this;
}

log_console& log_console::operator<<(const char* str)
{
	print(str);
	this->time = false;
	this->location = false;
	return *this;
}

log_console& log_console::operator<<(bool boolean)
{
	print((boolean ? std::string(color_bool_true) + " true" : std::string(color_bool_false) + " false") + color::reset);
	this->time = false;
	this->location = false;
	return *this;
}

template <typename type>
enable_if_t<std::is_floating_point_v<type>, log_console&> log_console::operator<<(type num)
{
	print(color_float_t + std::string(" ") + std::to_string(num) + color::reset);
	this->time = false;
	this->location = false;
	return *this;
}

template <typename type>
enable_if_t<std::is_integral_v<type>, log_console&> log_console::operator<<(type num)
{
	print(color_int_t + std::string(" ") + std::to_string(num) + color::reset);
	this->time = false;
	this->location = false;
	return *this;
}

log_console::~log_console()
{
	::fclose(output_stream);
}

void log_console::print(const std::string& str) const
{
	::fwrite(str.c_str(), sizeof(char), str.size(), output_stream);
}

struct termios* log_console::stdin_defaults = nullptr;
struct termios* log_console::stdout_defaults = nullptr;
struct termios* log_console::stderr_defaults = nullptr;

void log_console::setting_stdin()
{
	if (log_console::stdin_defaults == nullptr)
	{
		log_console::stdin_defaults = new termios;
	}
	::tcgetattr(0, log_console::stdin_defaults);
	struct termios settings = *log_console::stdin_defaults;
	settings.c_lflag &= (~ICANON);
	settings.c_lflag &= (~ECHO);
	settings.c_cc[VTIME] = 0;
	settings.c_cc[VMIN] = 1;
	::tcsetattr(0, TCSANOW, &settings);
}

void log_console::setting_stdout()
{
	if (log_console::stdout_defaults == nullptr)
	{
		log_console::stdout_defaults = new termios;
	}
	::tcgetattr(1, log_console::stdout_defaults);
	struct termios settings = *log_console::stdout_defaults;
	settings.c_lflag &= (~ICANON);
	settings.c_lflag &= (~ECHO);
	settings.c_cc[VTIME] = 0;
	settings.c_cc[VMIN] = 1;
	::tcsetattr(1, TCSANOW, &settings);
}

void log_console::setting_stderr()
{
	if (log_console::stderr_defaults == nullptr)
	{
		log_console::stderr_defaults = new termios;
	}
	::tcgetattr(2, log_console::stderr_defaults);
	struct termios settings = *log_console::stderr_defaults;
	settings.c_lflag &= (~ICANON);
	settings.c_lflag &= (~ECHO);
	settings.c_cc[VTIME] = 0;
	settings.c_cc[VMIN] = 1;
	::tcsetattr(2, TCSANOW, &settings);
}

void log_console::reset_all()
{
	if (log_console::stdin_defaults != nullptr)
	{
		::tcsetattr(0, TCSANOW, log_console::stdin_defaults);
		log_console::stdin_defaults = nullptr;
	}
	
	if (log_console::stdout_defaults != nullptr)
	{
		::tcsetattr(1, TCSANOW, log_console::stdout_defaults);
		log_console::stdout_defaults = nullptr;
	}
	
	if (log_console::stderr_defaults != nullptr)
	{
		::tcsetattr(1, TCSANOW, log_console::stderr_defaults);
		log_console::stderr_defaults = nullptr;
	}
}

// static operators

inline const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, const std::string& str)
{
	std::string copy;
	for (char i : str)
	{
		copy += i;
		if (i == '\n')
		{
			copy += "+-->";
		}
	}
	logger.first.print(copy);
	logger.first.time = false;
	logger.first.location = false;
	return logger;
}

const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, const char* str)
{
	std::string copy;
	for (; *str; ++str)
	{
		copy += *str;
		if (*str == '\n')
		{
			copy += "+-->";
		}
	}
	logger.first.print(copy);
	logger.first.time = false;
	logger.first.location = false;
	return logger;
}

inline const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, const decltype(l_location)& location)
{
	logger.first.print(
			(logger.first.time ? std::string() : std::string("\n")) + log_console::color_l_location + location.first
			+ log_console::color_l_location_separator + "::" + log_console::color_l_location + location.second.first + "()"
			+ log_console::color_l_location_separator + "::" + log_console::color_l_location + std::to_string(location.second.second)
			+ color::reset + "\n+-->"
	);
	logger.first.time = false;
	logger.first.location = true;
	return logger;
}

inline log_console& operator<<(const std::pair<log_console&, std::true_type>& logger, const decltype(l_time)& time)
{
	logger.first.print(
			(logger.first.location ? std::string() : std::string("\n")) + log_console::color_l_time + time.first
			+ log_console::color_l_time_separator + "  " + log_console::color_l_time + time.second
			+ color::reset + "\t"
	);
	logger.first.time = true;
	logger.first.location = false;
	return logger.first;
}

inline const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, bool boolean)
{
	logger.first.print((boolean ? std::string(log_console::color_bool_true) + " true" : std::string(log_console::color_bool_false) + " false") + color::reset);
	logger.first.time = false;
	logger.first.location = false;
	return logger;
}

template <typename type>
inline enable_if_t<std::is_integral_v<type>, const std::pair<log_console&, std::true_type>&> operator<<(const std::pair<log_console&, std::true_type>& logger, type num)
{
	logger.first.print(log_console::color_int_t + std::string(" ") + std::to_string(num) + color::reset);
	logger.first.time = false;
	logger.first.location = false;
	return logger;
}

template <typename type>
inline enable_if_t<std::is_floating_point_v<type>, const std::pair<log_console&, std::true_type>&> operator<<(const std::pair<log_console&, std::true_type>& logger, type num)
{
	logger.first.print(log_console::color_float_t + std::string(" ") + std::to_string(num) + color::reset);
	logger.first.time = false;
	logger.first.location = false;
	return logger;
}

#endif //KAZKUEME_LOG_CONSOLE_HPP
