#include <utility>
#include <iostream>
#include <termios.h>
//
// Created by imper on 6/12/21.
//
#ifndef KAZKUEME_LOG_CONSOLE_HPP
#define KAZKUEME_LOG_CONSOLE_HPP

template <typename T, T val>
struct val_is
{
	static constexpr T value = val;
};

template <typename T>
struct type_is
{
	using type = T;
};

template <bool, auto T_val, auto>
struct choose_val : val_is<decltype(T_val), T_val>
{
};

template <auto T_val, auto F_val>
struct choose_val<false, T_val, F_val> : val_is<decltype(F_val), F_val>
{
};

template <bool, typename T>
struct enable_if : type_is<T>
{
};

template <typename T>
struct enable_if<false, T>
{
};

template <bool expr, typename T> using enable_if_t = typename enable_if<expr, T>::type;

#define l_location std::pair<const char*, std::pair<const char*, int>>(__FILE__, {__func__, __LINE__})
#define l_time std::pair<const char*, const char*>(__DATE__, __TIME__)

namespace color
{
	static constexpr const char* reset      = "\033[0m";
	static constexpr const char* bold       = "\033[1m";
	static constexpr const char* light      = "\033[2m";
	static constexpr const char* italic     = "\033[3m";
	static constexpr const char* underlined = "\033[4m";
	static constexpr const char* blinking   = "\033[5m";
	static constexpr const char* default_bg = "\033[7m";
	static constexpr const char* strikeout  = "\033[9m";
	static constexpr const char* red        = "\033[31m";
	static constexpr const char* green      = "\033[32m";
	static constexpr const char* yellow     = "\033[33m";
	static constexpr const char* blue       = "\033[34m";
	static constexpr const char* purple     = "\033[35m";
	static constexpr const char* aqua       = "\033[36m";
	static constexpr const char* white      = "\033[37m";
	static constexpr const char* black_bg   = "\033[40m";
	static constexpr const char* red_bg     = "\033[41m";
	static constexpr const char* green_bg   = "\033[42m";
	static constexpr const char* yellow_bg  = "\033[43m";
	static constexpr const char* blue_bg    = "\033[44m";
	static constexpr const char* purple_bg  = "\033[45m";
	static constexpr const char* aqua_bg    = "\033[46m";
	static constexpr const char* white_bg   = "\033[47m";
}
class log_console
{
public:
	typedef void               (* state_change_function)(log_console& logger);
	
	enum l_flags : unsigned long
	{
		l_lock, l_unlock, l_flush, l_endl, l_endent
	};
	
	explicit log_console(int output_stream_socket);
	
	explicit log_console(FILE* output_stream);
	
	~log_console();
	
	inline void print(const std::string& str) const;
	
	inline void flush();
	
	static inline void lock();
	
	static inline void unlock();
	
	static inline void setting_stdin();
	
	static inline void setting_stdout();
	
	static inline void setting_stderr();
	
	static inline void reset_all();
	
	static constexpr const char* color_int_t                = color::purple;
	static constexpr const char* color_float_t              = color::blue;
	static constexpr const char* color_l_location           = "\033[35m\033[2m";
	static constexpr const char* color_l_location_separator = "\033[33m\033[2m";
	static constexpr const char* color_l_time               = "\033[35m\033[2m";
	static constexpr const char* color_l_time_separator     = "\033[33m\033[2m";
	static constexpr const char* color_bool_true            = color::green;
	static constexpr const char* color_bool_false           = color::red;
	static constexpr const char* log_arrow                  = "+--> ";
	
	inline static void on(log_console& logger)
	{ logger.is_logging_on = true; }
	
	inline static void off(log_console& logger)
	{ logger.is_logging_on = false; }

private:
	friend inline const std::pair<log_console&, std::true_type>&
	operator<<(log_console& logger, const std::remove_cvref_t<decltype(l_location)>& location);
	
	friend inline const std::pair<log_console&, std::true_type>& operator<<(log_console& logger, const std::remove_cvref_t<decltype(l_time)>& time);
	
	friend inline log_console& operator<<(log_console& logger, const std::string& str);
	
	friend inline log_console& operator<<(log_console& logger, const char* str);
	
	friend inline log_console& operator<<(log_console& logger, bool boolean);
	
	friend inline log_console& operator<<(log_console& logger, log_console::l_flags flag);
	
	template <typename type>
	friend enable_if_t<std::is_floating_point_v<type>, log_console&> operator<<(log_console& logger, type num);
	
	template <typename type>
	friend enable_if_t<std::is_integral_v<type>, log_console&> operator<<(log_console& logger, type num);
	
	friend inline const std::pair<log_console&, std::true_type>&
	operator<<(const std::pair<log_console&, std::true_type>& logger, const std::string& str);
	
	friend inline const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, const char* str);
	
	friend inline const std::pair<log_console&, std::true_type>&
	operator<<(const std::pair<log_console&, std::true_type>& logger, const decltype(l_location)& location);
	
	friend inline log_console& operator<<(const std::pair<log_console&, std::true_type>& logger, const decltype(l_time)& time);
	
	friend inline const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, bool boolean);
	
	friend inline const std::pair<log_console&, std::true_type>&
	operator<<(const std::pair<log_console&, std::true_type>& logger, log_console::l_flags flag);
	
	template <typename type>
	friend inline enable_if_t<std::is_integral_v<type>, const std::pair<log_console&, std::true_type>&>
	operator<<(const std::pair<log_console&, std::true_type>& logger, type num);
	
	template <typename type>
	friend inline enable_if_t<std::is_floating_point_v<type>, const std::pair<log_console&, std::true_type>&>
	operator<<(const std::pair<log_console&, std::true_type>& logger, type num);
	
	static struct termios* stdin_defaults;
	static struct termios* stdout_defaults;
	static struct termios* stderr_defaults;
	static pthread_mutex_t mutex;
	FILE* output_stream;
	bool is_logging_on = true;
	bool time          = false;
	bool location      = false;
};

pthread_mutex_t log_console::mutex = PTHREAD_MUTEX_INITIALIZER;

log_console::log_console(int output_stream_socket) : output_stream(::fdopen(output_stream_socket, "wb"))
{ }

log_console::log_console(FILE* output_stream) : output_stream(output_stream)
{ }

log_console::~log_console()
{ ::fclose(output_stream); }

void log_console::print(const std::string& str) const
{ ::fwrite(str.c_str(), sizeof(char), str.size(), output_stream); }

void log_console::flush()
{ ::fflush(this->output_stream); }

void log_console::lock()
{ pthread_mutex_lock(&log_console::mutex); }

void log_console::unlock()
{ pthread_mutex_unlock(&log_console::mutex); }

struct termios* log_console::stdin_defaults  = nullptr;
struct termios* log_console::stdout_defaults = nullptr;
struct termios* log_console::stderr_defaults = nullptr;

void log_console::setting_stdin()
{
	if (log_console::stdin_defaults == nullptr)
	{ log_console::stdin_defaults = new termios; }
	::tcgetattr(0, log_console::stdin_defaults);
	struct termios settings = *log_console::stdin_defaults;
	settings.c_lflag &= (~ICANON);
	settings.c_lflag &= (~ECHO);
	settings.c_cc[VTIME] = 0;
	settings.c_cc[VMIN]  = 1;
	::tcsetattr(0, TCSANOW, &settings);
}

void log_console::setting_stdout()
{
	if (log_console::stdout_defaults == nullptr)
	{ log_console::stdout_defaults = new termios; }
	::tcgetattr(1, log_console::stdout_defaults);
	struct termios settings = *log_console::stdout_defaults;
	settings.c_lflag &= (~ICANON);
	settings.c_lflag &= (~ECHO);
	settings.c_cc[VTIME] = 0;
	settings.c_cc[VMIN]  = 1;
	::tcsetattr(1, TCSANOW, &settings);
}

void log_console::setting_stderr()
{
	if (log_console::stderr_defaults == nullptr)
	{ log_console::stderr_defaults = new termios; }
	::tcgetattr(2, log_console::stderr_defaults);
	struct termios settings = *log_console::stderr_defaults;
	settings.c_lflag &= (~ICANON);
	settings.c_lflag &= (~ECHO);
	settings.c_cc[VTIME] = 0;
	settings.c_cc[VMIN]  = 1;
	::tcsetattr(2, TCSANOW, &settings);
}

void log_console::reset_all()
{
	if (log_console::stdin_defaults != nullptr)
	{
		::tcsetattr(0, TCSANOW, log_console::stdin_defaults);
		log_console::stdin_defaults = nullptr;
	}
	if (log_console::stdout_defaults != nullptr)
	{
		::tcsetattr(1, TCSANOW, log_console::stdout_defaults);
		log_console::stdout_defaults = nullptr;
	}
	if (log_console::stderr_defaults != nullptr)
	{
		::tcsetattr(1, TCSANOW, log_console::stderr_defaults);
		log_console::stderr_defaults = nullptr;
	}
}

// static operators
inline log_console& operator<<(log_console& logger, const log_console::state_change_function& state_change_function)
{
	state_change_function(logger);
	return logger;
}

inline const std::pair<log_console&, std::true_type>& operator<<(log_console& logger, const std::remove_cvref_t<decltype(l_location)>& location)
{
	if (logger.is_logging_on)
	{
		logger.
					  print((logger
									 .location ?
				
							 std::string() : std::string("\n")
				
							) + log_console::color_l_location + location.first + log_console::color_l_location_separator + "::" +
							log_console::color_l_location + location.second.first + log_console::color_l_location_separator + "::" +
							log_console::color_l_location +
							std::to_string(
									location
											.second.second
							) + color::reset + "\n+--> "
		);
		logger.
					  time     = false;
		logger.
					  location = true;
	}
	return *new std::remove_cvref_t<decltype(operator<<(logger, l_location))>{
			logger,
			
			std::true_type()
		
	};
}

inline const std::pair<log_console&, std::true_type>& operator<<(log_console& logger, const std::remove_cvref_t<decltype(l_time)>& time)
{
	if (logger.is_logging_on)
	{
		logger.print(
				(logger.time ? std::string() : std::string("\n")) + log_console::color_l_time + time.first + log_console::color_l_time_separator +
				"::" + log_console::color_l_time + time.second + color::reset + "\t"
		);
		logger.time     = true;
		logger.location = false;
	}
	return *new std::remove_cvref_t<decltype(operator<<(logger, l_time))>{logger, std::true_type()};
}

inline log_console& operator<<(log_console& logger, const std::string& str)
{
	if (logger.is_logging_on)
	{
		logger.print(str);
		logger.time     = false;
		logger.location = false;
	}
	return logger;
}

inline log_console& operator<<(log_console& logger, const char* str)
{
	if (logger.is_logging_on)
	{
		logger.print(str);
		logger.time     = false;
		logger.location = false;
	}
	return logger;
}

inline log_console& operator<<(log_console& logger, bool boolean)
{
	if (logger.is_logging_on)
	{
		logger.print(
				(boolean ? std::string(log_console::color_bool_true) + " true" : std::string(log_console::color_bool_false) + " false") + color::reset
		);
		logger.time     = false;
		logger.location = false;
	}
	return logger;
}

inline log_console& operator<<(log_console& logger, log_console::l_flags flag)
{
	if (logger.is_logging_on)
	{
		switch (flag)
		{
			case log_console::l_flags::l_lock:
				log_console::lock();
				break;
			case log_console::l_flags::l_unlock:
				log_console::unlock();
				break;
			case log_console::l_flags::l_flush:
				logger.flush();
				break;
			case log_console::l_flags::l_endl:
				logger.print("\n");
				logger.flush();
				break;
			case log_console::l_flags::l_endent:
				logger.print(log_console::log_arrow);
				logger.print("\n");
				logger.flush();
				log_console::unlock();
				break;
		}
	}
	return logger;
}

template <typename type>
enable_if_t<std::is_floating_point_v<type>, log_console&> operator<<(log_console& logger, type num)
{
	if (logger.is_logging_on)
	{
		print(log_console::color_float_t + std::string(" ") + std::to_string(num) + color::reset);
		logger.time     = false;
		logger.location = false;
	}
	return logger;
}

template <typename type>
enable_if_t<std::is_integral_v<type>, log_console&> operator<<(log_console& logger, type num)
{
	if (logger.is_logging_on)
	{
		print(log_console::color_int_t + std::string(" ") + std::to_string(num) + color::reset);
		logger.time     = false;
		logger.location = false;
	}
	return logger;
}

inline const std::pair<log_console&, std::true_type>&
operator<<(const std::pair<log_console&, std::true_type>& logger, const log_console::state_change_function& state_change_function)
{
	state_change_function(logger.first);
	return logger;
}

inline const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, const std::string& str)
{
	if (logger.first.is_logging_on)
	{
		std::string copy;
		for (char   i : str)
		{
			copy += i;
			if (i == '\n')
			{ copy += log_console::log_arrow; }
		}
		logger.first.print(copy);
		logger.first.time     = false;
		logger.first.location = false;
	}
	return logger;
}

const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, const char* str)
{
	if (logger.first.is_logging_on)
	{
		std::string copy;
		for (; *str; ++str)
		{
			copy += *str;
			if (*str == '\n')
			{ copy += log_console::log_arrow; }
		}
		logger.first.print(copy);
		logger.first.time     = false;
		logger.first.location = false;
	}
	return logger;
}

inline const std::pair<log_console&, std::true_type>&
operator<<(const std::pair<log_console&, std::true_type>& logger, const decltype(l_location)& location)
{
	if (logger.first.is_logging_on)
	{
		logger.first.
				print((logger
							   .first.time ?
				
					   std::string() : std::string("\n")
				
					  ) + log_console::color_l_location + location.first + log_console::color_l_location_separator + "::" +
					  log_console::color_l_location + location.second.first + "()" + log_console::color_l_location_separator + "::" +
					  log_console::color_l_location +
					  std::to_string(
							  location
									  .second.second
					  ) + color::reset + "\n+-->  "
		);
		logger.first.
				time     = false;
		logger.first.
				location = true;
	}
	return
			logger;
}

inline log_console& operator<<(const std::pair<log_console&, std::true_type>& logger, const decltype(l_time)& time)
{
	if (logger.first.is_logging_on)
	{
		logger.first.print((logger.first.location ? std::string() : std::string("\n")) + log_console::color_l_time + time.first +
						   log_console::color_l_time_separator + "  " + log_console::color_l_time + time.second + color::reset + "\t"
		);
		logger.first.time     = true;
		logger.first.location = false;
	}
	return logger.first;
}

inline const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, bool boolean)
{
	if (logger.first.is_logging_on)
	{
		logger.first.print((boolean ? std::string(log_console::color_bool_true) + " true" : std::string(log_console::color_bool_false) + " false") +
						   color::reset
		);
		logger.first.time     = false;
		logger.first.location = false;
	}
	return logger;
}

inline const std::pair<log_console&, std::true_type>& operator<<(const std::pair<log_console&, std::true_type>& logger, log_console::l_flags flag)
{
	if (logger.first.is_logging_on)
	{
		switch (flag)
		{
			case log_console::l_flags::l_lock:
				log_console::lock();
				break;
			case log_console::l_flags::l_unlock:
				log_console::unlock();
				break;
			case log_console::l_flags::l_flush:
				logger.first.flush();
				break;
			case log_console::l_flags::l_endl:
				logger.first.print("\n");
				logger.first.flush();
				break;
			case log_console::l_flags::l_endent:
				logger.first.print(log_console::log_arrow);
				logger.first.print("\n");
				logger.first.flush();
				log_console::unlock();
				break;
		}
	}
	return logger;
}

template <typename type>
inline enable_if_t<std::is_integral_v<type>, const std::pair<log_console&, std::true_type>&>
operator<<(const std::pair<log_console&, std::true_type>& logger, type num)
{
	if (logger.first.is_logging_on)
	{
		logger.first.print(log_console::color_int_t + std::string(" ") + std::to_string(num) + color::reset);
		logger.first.time     = false;
		logger.first.location = false;
	}
	return logger;
}

template <typename type>
inline enable_if_t<std::is_floating_point_v<type>, const std::pair<log_console&, std::true_type>&>
operator<<(const std::pair<log_console&, std::true_type>& logger, type num)
{
	if (logger.first.is_logging_on)
	{
		logger.first.print(log_console::color_float_t + std::string(" ") + std::to_string(num) + color::reset);
		logger.first.time     = false;
		logger.first.location = false;
	}
	return logger;
}

#endif //KAZKUEME_LOG_CONSOLE_HPP